[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Phylogenetics & Phylogenomics",
    "section": "",
    "text": "OverviewAuthorsCitationAcknowledgements\n\n\nInclude a one-paragraph summary of the course here.\n\n\n\n\n\n\nLearning Objectives\n\n\n\n\nList course learning objectives here.\nThese describe concepts the learners should grasp and techniques they should be able to use by the end of the course.\nYou can think of these as completing the phrase “after this course, the participant should be able to…”\nThey are not supposed to be as detailed as the learning objectives of each section, but more high-level.\n\n\n\n\nTarget Audience\nBrief description of target audience here.\n\n\nPrerequisites\nDetail any prerequisite skills needed to attend this course, with links to other relevant materials/courses if possible.\n\n\n\nAbout the authors:\n\nAndries van Tonder  \nAffiliation: Dpt Veterinary Medicine, University of Cambridge\nRoles: writing - original draft; conceptualisation; coding\nNathanael Walker-Hale  \nAffiliation: Dpt Plant Sciences, University of Cambridge\nRoles: writing - review & editing; conceptualisation; coding\nNicola De Maio  \nAffiliation: European Bioinformatic Institute (EMBL-EBI), Cambridge\nRoles: writing - review & editing; conceptualisation; coding\n\n\n\n\nPlease cite these materials if:\n\nYou adapted or used any of them in your own teaching.\nThese materials were useful for your research work. For example, you can cite us in the methods section of your paper: “We carried our analyses based on the recommendations in TODO.”.\n\nYou can cite these materials as:\n\nTODO\n\nOr in BibTeX format:\n@Misc{,\n  author = {},\n  title = {},\n  month = {},\n  year = {},\n  url = {},\n  doi = {}\n}\n\n\n\n\nList any other sources of materials that were used.\nOr other people that may have advised during the material development (but are not authors)."
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "Setup",
    "section": "",
    "text": "Workshop Attendees\n\n\n\nIf you are attending one of our workshops, we will provide a training environment with all of the required software and data.\nIf you want to setup your own computer to run the analysis demonstrated on this course, you can follow the instructions below."
  },
  {
    "objectID": "materials/01-foundations/00-foundations.html",
    "href": "materials/01-foundations/00-foundations.html",
    "title": "Molecular Phylogenetics - an Introduction",
    "section": "",
    "text": "Learning Objectives\n\n\n\n\nFundamental concepts in phylogenetics.\nWhat is a sequence alignment and how to estimate one.\nDistance-based phylogenetic methods.\nMaximum likelihood phylogenetics.\nBayesian phylogenetics."
  },
  {
    "objectID": "materials/01-foundations/00-foundations.html#introduction",
    "href": "materials/01-foundations/00-foundations.html#introduction",
    "title": "Molecular Phylogenetics - an Introduction",
    "section": "Introduction",
    "text": "Introduction\nThe evolutionary history of species is determined in large part by speciations. A phylogenetic tree summarizes such a history, by representing speciations as bifurcations. Each branch of the tree represents evolution of an ancestral species.\nSimilarly, phylogenetic trees can be used to describe short-term evolutionary histories, such as those of pathogens within epidemics. In this context, bifurcations in the tree are intertwined with transmission events between hosts.\nIn all these cases, and more, the phylogenetic tree shapes the relatedness of the considered genomes, with genomes being nearer in the tree typically being more similar to each other. Using this fact, we can reconstruct phylogenetic trees starting from observed genomes - with this course, we will discuss how, and how to prevent common pitfalls in molecular phylogenetics."
  },
  {
    "objectID": "materials/01-foundations/00-foundations.html#what-is-a-phylogenetic-tree",
    "href": "materials/01-foundations/00-foundations.html#what-is-a-phylogenetic-tree",
    "title": "Molecular Phylogenetics - an Introduction",
    "section": "What is a phylogenetic tree",
    "text": "What is a phylogenetic tree\nA phylogenetic tree is a graph: it is made of nodes and edges, with one edge connecting two nodes.\nA node can represent an extant species, and extinct one, or a sampled pathogen: these are all cases of “terminal” nodes, nodes in the tree connected to only one edge, and usually associated with data, such as a genome sequence.\nA tree also contains “internal” nodes: these usually represent most recent common ancestors (MRCAs) of groups of terminal nodes, and are typically not associated with observed data, although genome sequences and other features of these ancestors can be statistically inferred. An internal node is most often connected to 3 branches (two descendants and one ancestral), but a multifurcation node can have any number >2 of descendant branches.\n\n\n\n\n\n\nMultifurcations\n\n\n\nA multifurcation can happen for example when a species radiates, or speciates in >2 descendant species at the same time. Similarly, multifurcations in pathogen trees can represent superspreading events. However, most often multifurcations are inferred from data when a branch of the true evolutionary history tree is not long enough to have caused mutations in the genetic sequences being considered.\nWhen dealing with multifurcations, be aware that many phylogenetic software will not allow them, which might cause multifurcating trees to be represented as bifurcating trees with very short branches, or might cause errors in the execution of some software.\n\n\nAn essential feature of phylogenetic trees is that they have no cycles: for a rooted tree, this means that each non-root node has exactly one parent branch above it connected to it. For an unrooted tree, this means that you cannot find a path starting and ending at the same node and never traversing the same branch twice.\n\n\n\n\n\n\nLateral gene transfers\n\n\n\nThe assumption of no cycles in a tree means that, in practice, one phylogenetic tree in itself cannot describe hybridizations and other instances of “lateral” evolution such as recombination, gene transfers, etc, and in general all cases in which one genome can have multiple parents. These events can instead be described with collections of trees (for example one tree for each portion of the genome that shares the same phylogenetic tree, or “gene tree”), or with generalizations of the tree structure, such as phylogenetic networks, ancestral recombination graphs, etc.\n\n\n\nBranch lengths and timed trees\nThe branches of a tree can be associated with numerical values: their lengths. These lengths however do not always represent the same thing, and in particular one has to be careful with the unit in which branch lengths are expressed.\nMost commonly, branch lengths represent divergence. Divergence can be represented in terms of number of mutations per genome position expected on a branch: for example a branch length of 0.01 will mean that, approximately, we expect that 1% of the genome of the considered species/lineage mutated along this branch. However, some phylogenetic methods, in particular parsimony-based methods, might represent branch lengths with integer numbers, for example a value of 24 would mean 24 substitutions expected on this branch for the considered genetic sequence.\nHowever, branch lengths can also represent time, and trees with such branch lengths are called “timed trees”. While we can estimate divergence-based branches directly from the genome data, to infer timed trees we need additional information. A species tree can be timed using information about the molecular clock, or about the time of fossils. A pathogen tree is often timed using the time data of when pathogen samples were collected, since older samples are expected to be closer in time distance to the root of the tree.\n\n\nTree rooting\nA phylogenetic tree can be rooted: this means that a root node is specified, and in turn this allows to determine which nodes in the tree are ancestors of which other nodes. In an unrooted tree this is not possible. To make a tree rooted (“tree rooting”) one often uses: - An outgroup, - The assumption that the tree is ultrametric (all terminal nodes have the same distance from the root), - Time information (such as the time in which the pathogen samples were collected), - A non-reversible model (genome evolution can leave a directional mark on the genome, for example if the number of T nucleotides increases with time), - Some or all of the above.\n\n\nTree topology\nA clade is the set of all terminal nodes descending from the same ancestor. Each branch and internal node in a tree is associated with a clade. If two trees have the same clades, we say that they have the same topology. If they have the same clades and the same branch lengths, the two tree are equivalent, that is, they represent the same evolutionary history.\n\n\nNewick format\nWe often need to represent trees in text format, for example to communicate them as input or output of phylogenetic inference software. The Newick format is the most common text format for phylogenetic trees.\nThe Newick format encloses each subtree (the part of a tree relating the terminal nodes part of the same clade) with parenthesis, and separates the two child nodes of the same internal node with a “,”. At the end of a Newick tree there is always a “;”.\nFor example, the Newick format of a rooted tree relating two samples “S1” and “S2”, with distances from the root respectively of 0.1 and 0.2, is\n(S1:0.1,S2:0.2);\nIf we add a third sample “S3” as an outgroup, the tree might become\n((S1:0.1,S2:0.2):0.3,S3:0.4);\n\n\nApplications of phylogenetic trees\nIn may cases, the phylogenetic tree represents the end results of an analysis, for example if we are interested in the evolutionary history of a set of species.\nHowever, in many cases a phylogenetic tree represents an intermediate step, and there are many ways in which phylogenetic trees can be used to help understand evolution and the spread of infectious disease.\nIn many cases, we may want to know more about genome evolution, for example about mutational pressures, but more frequently about selective pressures. Selection can affect genome evolution in many ways such as slowing down evolution of portion of the genome in which changes are deleterious (“purifying selection”). Instead, “positive selection” can favor changes at certain positions of the genome, effectively accelerating their evolution. Using genome data and phylogenetic trees, molecular evolution methods can infer different types of selection acting in different parts of the genome and different branches of a tree (see e.g. https://doi.org/10.1146/annurev.genet.39.073003.112420 ).\nIn other scenarios, we might want to combine genetic sequence data with geographical data to reconstruct how species, or pathogens, spread through space and time. This is what we call phylogeography (see e.g. https://doi.org/10.1146/annurev.ecolsys.38.091206.095702 , https://doi.org/10.1016/j.coviro.2011.10.003 ).\nIt is also possible to use the shape of a phylogenetic tree to reconstruct the past prevalence of an infectious disease - this is called “phylodynamics” (see e.g. https://doi.org/10.1371/journal.pcbi.1002947 ).\nThis is only a few of many possible applications!\n\n\nCaveats\nAs mentioned before, any non tree-like evolutionary process cannot be captured by phylogenetic trees and has the potential of misleading phylogenetic analyses.\nAs genes evolve, they can undergo gene loss or duplication. This is one of several reasons why gene trees (where splits might represent gene duplication events and not just speciation events) can differ from species trees.\nWith hybridation a new species can be formed by merging the genomes of other species. This means that part of the genes will come from one ancestor and the rest from another. Likewise, part of the gene trees will support one species tree, and the rest will support another one.\nThe genomes of many Eukaryotes undergo recombination each generation. This means that one usually cannot build a single tree from the multiple genomes within the same species; instead, one can infer gene trees for smaller portions of the genome. When using a single genome from each species, it is common to assume a single tree. However, even in this case within-species recombination of ancestral species can cause diversity in gene trees, a phenomenon we call “incomplete lineage sorting” (see e.g. https://doi.org/10.1093/sysbio/syw082 ).\nWith lateral gene transfer, genes move from one species to another. These genes will then have different phylogenetic trees.\nIn bacteria, recombination has usually a more limited effect than in Eukaryotes. As such, while different parts of the genome might have evolved under different trees, usually these trees are similar to the backbone phylogeny of the non-recombining parts of the genome, which we call “clonal frame”, see e.g. https://doi.org/10.1016/j.tim.2010.04.002 ."
  },
  {
    "objectID": "materials/01-foundations/00-foundations.html#alignment",
    "href": "materials/01-foundations/00-foundations.html#alignment",
    "title": "Molecular Phylogenetics - an Introduction",
    "section": "Alignment",
    "text": "Alignment\nIn molecular phylogenetic we use sequence data to infer trees. However, sequence data usually needs to be “aligned”. This is because the same homologous sequence can be of different length for different species due to indels, and this makes it hard to reconstruct which substitutions occurred where. An alignment is a matrix containing one sequence per row. To make the rows/sequences in the matrix of the same length, we pad them with gap “-” characters.\nHowever, we can’t put arbitrarily gap characters in the matrix: this would lead to inaccurate trees. Say we have sequences  ATCG CG\nwhile this might be a reasonable alignment:  ATCG  --CG\nthis one is typically much more unlikely:  A-TCG  -CG--\nAlignment methods are usually guided by one of two principles: - Evolutionary alignments want to place homologous characters in the same alignment column. Characters are homologous if they descended from the same ancestral character: while they might have been substituted with different characters, they have not been inserted. This is usually the same assumption made by phylogenetic methods when interpreting an alignment. - Structural alignments want similar characters to be in the same column, so it makes sense that two characters are in the same column even if they are not homologous, but if they have similar functions within the sequence.\nAn evolutionary alignment represents an inference regarding the evolutionary sequence of the considered species, in particular regarding insertions and deletions. Phylogenetic inference methods usually don’t use insertion and deletion events to infer the tree, but they still assume that characters in the same alignment column are homologous.\n\nAlignment inference\nPairwise alignment means aligning only two sequences. One popular technique for pairwise alignment is dynamic programming in a form similar to the Needleman-Wunsch algorithm.\nMultiple sequence alignment (MSA) means aligning >2 sequences, and is a much more computationally complex process. A common heuristic strategy is “progressive alignment”, where 2 sub-alignments at the time are pairwise aligned, starting from the 2 most closely related sequences, as defined in a given guide tree.\nWith iterative alignment, one sequence at the time is removed from the alignment, and then re-aligned with the rest, with the aim of improving the alignment.\nThere are many alignment software available, e.g. Clustal, MAFFT, MUSCLE, PRANK, T-Coffee, ProbAlign. At short divergence these typically give similar results, but with highly divergent sequences alignments can be very different between methods. There is no clear consensus on which approach is best, although MAFFT is often considered a great compromise of accuracy/speed; for the inference of selection, there is evidence that evolutionary aligners like PRANK are robust to biases leading to falsely infer positive selection due to overalignment. There is no clear consensus regarding methods to “clean” alignments or to assess the confidence of different alignment regions.\n\n\nAlignment practical\nGiven a set of non-aligned sequences, let’s generate one or more alignments (to be completed…)."
  },
  {
    "objectID": "materials/01-foundations/00-foundations.html#phylogenetic-inference---distance-based-methods",
    "href": "materials/01-foundations/00-foundations.html#phylogenetic-inference---distance-based-methods",
    "title": "Molecular Phylogenetics - an Introduction",
    "section": "Phylogenetic inference - distance-based methods",
    "text": "Phylogenetic inference - distance-based methods\nPhylogenetic relationships impact genomes in that closely related sequences are expected to be more similar to each other. This is the basic idea behind distance-based methods: the phylogenetic distance between two samples (the sum of the branch lengths separating the two sequences in the tree) is expected to be proportional to the divergence between the considered genomes.\nDistance-based methods first calculate the distances between pairs of aligned sequences, and from these they estimate their pairwise divergence. These divergence estimates (which make up the “distance matrix”) are then used as constraints to build a phylogenetic tree.\nNeighbor-Joining (NJ), one of the most popular distance-based approaches, first creates clades of the most closely related sequences. Then, it updates the distance matrix, replacing the entries for these sequences with distances for the newly created clades. This is repeated iteratively until all clades and branch lengths have been estimated.\nDistance-based methods are popular thanks to their simplicity and computational efficiency. In particular, NJ trees are often used as starting trees for other more complex phylogenetic inference methods.\n\nNeighbor-Joining inference practical\nInfer a tree with NJ (to be completed…)"
  },
  {
    "objectID": "materials/01-foundations/00-foundations.html#phylogenetic-inference---maximum-parsimony",
    "href": "materials/01-foundations/00-foundations.html#phylogenetic-inference---maximum-parsimony",
    "title": "Molecular Phylogenetics - an Introduction",
    "section": "Phylogenetic inference - Maximum parsimony",
    "text": "Phylogenetic inference - Maximum parsimony\nMaximum parsimony phylogenetic inference is based on the assumption that a tree that can explain the data (the alignment) requiring the fewest mutations is the preferable tree.\n\nTree search\nMaximum parsimony methods usually start from an initial tree, which can be estimated for example with NJ, and then try to iteratively improve the tree by attempting to decrease its parsimony score. The parsimony score is defined as the minimum number of mutations required by a tree to explain the alignment. One cannot attempt to evaluate all possible trees, because their number is typically too large, and this is why we use heuristic tree searches.\nTo improve the tree, methods often perform small changes to the tree, and then evaluate the parsimony score of the modified tree. A type of change is “nearest neighbor interchange”, where two nearby subtrees are swapped. Another is “subtree prune and regraft” when a subtree is removed from the tree and re-attached somewhere else.\n\n\nLong branch attraction\nWhile maximum parsimony trees are generally regarded as useful, they are not exempt from biases. One of the most studied of these biases is “long branch attraction”: when very long branches are present in the true tree, these branch tend to be biasedly clustered together in the inferred maximum parsimony trees. These biases are however not expected when studying short divergence data.\n\n\nMaximum parsimony inference practical\nInfer a tree with maximum parsimony?"
  },
  {
    "objectID": "materials/01-foundations/00-foundations.html#phylogenetic-inference---maximum-likelihood",
    "href": "materials/01-foundations/00-foundations.html#phylogenetic-inference---maximum-likelihood",
    "title": "Molecular Phylogenetics - an Introduction",
    "section": "Phylogenetic inference - maximum likelihood",
    "text": "Phylogenetic inference - maximum likelihood\nThe phylogenetic likelihood of a tree T is the probability of the alignment A conditional on the tree T: P(A|T). Maximum likelihood methods use the likelihood function to evaluate how realistic (“likely”) different trees are, and aim at returning the tree with the highest value (the maximum likelihood tree).\nThe likelihood function is typically computed by assuming that all sites in the alignment evolve independently of one another, and by using a dynamic programming approach (the Felsenstein pruning algorithm) to calculate the likelihood of each site.\n\nSubstitution models\nA key component need for calculating a tree likelihood is a substitution model. Substitution models describes how states (be it nucleotides, amino acids, codons, or phenotypes) transition between one another. For example, two nucleotides with a high substitution rates between them are expected to substitute each other more frequently. Substitution models can be broadly split between parametric (the entries of the substitution matrix are estimated from the considered data) or empirical (the rates are pre-estimated, usually using a large database). Model selection methods can select a substitution model for phylogenetic inference according to different optimality criteria.\n\n\nTree search\nMaximum likelihood methods, like maximum parsimony methods, start from an initial tree, and then try to iteratively improve it by attempting to increase its likelihood score typically via “nearest neighbor interchange” and “subtree prune and regraft” moves.\nIt is not guarantee that these sets of move will lead us to find the maximum tree - we might instead land on a local maximum tree, one that is not optimal, but that we can’t improve anymore with our set of moves.\n\n\nMaximum likelihood inference practical\nInfer a tree with maximum likelihood? Maybe also run model selection software?"
  },
  {
    "objectID": "materials/01-foundations/00-foundations.html#tree-uncertainty---bootstrap",
    "href": "materials/01-foundations/00-foundations.html#tree-uncertainty---bootstrap",
    "title": "Molecular Phylogenetics - an Introduction",
    "section": "Tree uncertainty - bootstrap",
    "text": "Tree uncertainty - bootstrap\nAll the methods for phylogenetic inference that we discussed so far aim at estimating a single realistic tree, but they don’t automatically tell us how confident we should be in the tree, or in individual branches of the tree.\nOne common way to address this limitation is using the phylogenetic bootstrap approach (Felsenstein, 1985). This consist first in sampling a large number (say, 1000) of bootstrap alignments. Each of these alignments has the same size as the original alignment, and is obtained by sampling with replacement the columns of the original alignment; in each bootstrap alignment some of the columns of the original alignment will usually be absent, and some other columns would be represented multiple times. We then infer a bootstrap tree from each bootstrap alignment. Because the bootstrap alignments differ from each other and from the original alignment, the bootstrap trees might different between each other and from the original tree. The bootstrap support of a branch in the original tree is then defined as the proportion of times in which this branch is present in the bootstrap trees."
  },
  {
    "objectID": "materials/01-foundations/00-foundations.html#bayesian-phylogenetic-inference",
    "href": "materials/01-foundations/00-foundations.html#bayesian-phylogenetic-inference",
    "title": "Molecular Phylogenetics - an Introduction",
    "section": "Bayesian phylogenetic inference",
    "text": "Bayesian phylogenetic inference\nBayesian methods, like maximum likelihood ones, also use the likelihood function to score trees. However, their aim is not to retrieve the tree with the highest likelihood, but rather to sample from the posterior distribution of trees.\nThis means that trees are not evaluated solely based on their likelihood, but also based on a “tree prior” function. These tree priors can be very useful for estimating model parameters that affect the tree shape, for example the history of prevalence of an infectious disease through time.\nIt also means that the output of a Bayesian method includes multiple trees, representing tree inference uncertainty.\nBayesian phylogenetics is particularly useful at short divergence, since parts of the of phylogeny might be very uncertain due to lack of substitutions.\nBayesian methods typically use Monte Carlo Markov Chain (MCMC) for tree space exploration. This is somewhat similar to the maximum likelihood tree search, in that a current tree is randomly modified, and the modification can be accepted or rejected based on its probability. However, MCMC allows the tree probability to decrease as well as to increase. At the end of the MCMC run, an initial number of trees is discarded (the “burn-in”) and a sample of the trees and parameter values visited is given to the user.\n\nBayesian inference practical\nUse BEAST 1 or 2 for a simple phylogenetic estimation run?"
  },
  {
    "objectID": "materials/01-foundations/00-foundations.html#summary",
    "href": "materials/01-foundations/00-foundations.html#summary",
    "title": "Molecular Phylogenetics - an Introduction",
    "section": "Summary",
    "text": "Summary\n\nMolecular phylogenetics typically requires aligned sequences. Several methods are available for sequence alignment.\nDistance-based methods like neighbor-joining offer efficient ad heuristic tree estimates.\nMaximum likelihood methods are typically slower but are statistically consistent and can include complex substitution models.\nBayesian methods are usually the slowest but most encompassing ones, measuring tree uncertainty and allowing complex evolutionary models such as phylodynamics."
  },
  {
    "objectID": "materials/01-foundations/00-template.html",
    "href": "materials/01-foundations/00-template.html",
    "title": "Lesson Title Here",
    "section": "",
    "text": "Learning Objectives\n\n\n\n\nList skills and concepts that learners should grasp after this lesson."
  },
  {
    "objectID": "materials/02-prokaryotes/2.1-know_your_bug.html",
    "href": "materials/02-prokaryotes/2.1-know_your_bug.html",
    "title": "Know Your Bug",
    "section": "",
    "text": "Learning Objectives\n\n\n\n\nUnderstand that there are different ways to construct a phylogenetic tree depending on what species you’re analysing"
  },
  {
    "objectID": "materials/02-prokaryotes/2.1-know_your_bug.html#introduction",
    "href": "materials/02-prokaryotes/2.1-know_your_bug.html#introduction",
    "title": "Know Your Bug",
    "section": "Introduction",
    "text": "Introduction\nThe purpose of this module is to provide a broad overview of inferring prokaryote phylogenetic trees with a focus on bacterial genomes.\nBefore starting your analysis, it’s important to understand the characteristics of the species you’re working with as this will determine how best to proceed. In particular, you need to understand how much genetic diversity or plasticity is present in your bug and whether or not it recombines. For instance the approach you take to build a phylogenetic tree of Mycobacterium tuberculosis genomes will differ from the methods you’d use to build a tree with Escherichia coli. To help with making your decision, we’ve provided a flowchart which outlines the best approach to take depending on what your dataset is composed of:\n\n\n\nFlowchart showing different approaches to building a bacterial phylogenetic tree\n\n\nThe two most commonly applied methods for generating muliple sequence alignments to use for phylogenetic tree inference in bacterial genomics are reference-based whole genome alignments and core genome alignments generated by comparing genes between different isolates and identifying the genes found in all or nearly all isolates (the core genome). As a broad rule of thumb, if your species is not genetically diverse and doesn’t recombine (TB, Brucella) then picking a suitable good-quality reference and generating a whole genome alignment is appropriate. However, when you have a lot of diversity or multiple divergent lineages (E. coli) then a single reference may not represent all the diversity in your dataset. Here it would be more appropriate to create de novo assemblies, annotate them and then use a tool like roary or panaroo to infer the pan-genome and create a core genome alignment. The same phylogenetic methods are then applied to either type of multiple sequence alignment."
  },
  {
    "objectID": "materials/02-prokaryotes/2.1-know_your_bug.html#mapping-to-a-reference",
    "href": "materials/02-prokaryotes/2.1-know_your_bug.html#mapping-to-a-reference",
    "title": "Know Your Bug",
    "section": "Mapping to a reference",
    "text": "Mapping to a reference\nThe purpose of mapping sequence reads to a reference genome is to identify any phylogenetic-informative DNA changes (normally single nucleotide polymorphisms (SNPs)) in your samples relative to the reference. For the positions in the reference genome where we don’t see any differences in the mapped samples, we assume that that the nucleotide in that position is the one found in the reference. There are a number of different tools for mapping sequence data to a reference genome (bwa, bowtie2) and calling variants (bcftools, freebayes), but the easiest way to do this is to use a pipeline such as nf-core/bactmap. nf-core/bactmap is a bioinformatics best-practice analysis pipeline for mapping short reads from bacterial whole genome sequences to a reference sequence, identifying the variants in each sample and creating a multiple sequence alignment that can then be used to create a phylogeny. The pipeline is built using Nextflow, a workflow tool to run tasks across multiple compute infrastructures in a very portable manner. It uses Docker/Singularity containers making installation trivial and results highly reproducible.\n\nPicking a reference\nPicking the best reference for your dataset is very important as this can have a large effect on the phylogenetic tree that’s constructed. For some species with low diversity e.g. M. tuberculosis, it is usual to use the same reference (the lab strain H37v) regardless of what your dataset is comprised of. If your dataset is comprised of a single lineage (e.g. ST, CC), the best reference to use is one that is from the same or a closely related lineage. For many of the most commonly sequenced bacteria, there are several different reference sequences available in public databases such as RefSeq, meaning that, in most instances, you can find a suitable reference. However, for more diverse organisms, a single reference may not represent all the samples in your dataset. In this instance, you may want consider comparing the similarity of your samples to a number of different reference sequences and pick the one that is similar to most samples in your dataset.\n\n\nRemoving recombination\nRecombination in bacteria is characterized by DNA transfer from one organism or strain (the donor) to another organism/strain (the recipient) or the uptake of exogenous DNA from the surrounding environment. Broadly, there are three different types of bacterial recombination:\n\nTransformation: the uptake of exogenous DNA from the environment\nTransduction: virus-mediated (phage) transfer of DNA between bacteria\nConjugation: the transfer of DNA from one bacterium to another via cell-to-cell contact\n\nThe sequences transferred via recombination can influence genome-wide measures of sequence simularity more than vertically-inherited point mutations that are the signal of shared common ancestor. Thus, identifying recombinant regions and accounting for their potentially different phylogenetic history is crucial when examining the evolutionary history of bacteria. In practice, what this means is that we remove (mask) previously identified recombinant regions in our multiple sequence alignmnents before we proceed with phylogenetic tree inference. The two most commonly used tools to do this are Gubbins and ClonalFrameML. It’s important to note that Gubbins cannot be used on the core gene alignment produced by tools like roary or panaroo as Gubbins requires a whole genome alignment as input in order to analyse the spatial distribution of base substitutions. For this reason, the finer scale phylogenetic structure of phylogenetic trees generated using a core gene alignment may be less accurate. If we want to properly account for recombination in this instance, typically we would perform some kind of clustering on our initial tree, then map sequence data for the samples within a cluster to a suitable reference before running our recombination removal tool of choice."
  },
  {
    "objectID": "materials/02-prokaryotes/2.1-know_your_bug.html#pan-genome-analysis",
    "href": "materials/02-prokaryotes/2.1-know_your_bug.html#pan-genome-analysis",
    "title": "Know Your Bug",
    "section": "Pan-genome analysis",
    "text": "Pan-genome analysis\nWhen you have a very diverse dataset where no single reference is going to accurately reflect the population structure withn your dataset, then a reference independent approach such as constructing a core gene alignment as part of a pan-genome analysis is the best way to build a multiple sequence alignmnet for phylogenetic inference. There are several tools available to do this including roary, panaroo and panX. It’s important to note that the alignments produced using these tools only contain the genes found in all or nearly all of the samples meaning that the amount of potentially phylogenetically informative information is reduced. For this reason, core gene based phylogenies are useful for looking at a whole species but it’s generally preferable to perform clustering and create new sub-trees using reference mapping if you’re interested in examining the relationship between more closely related genomes."
  },
  {
    "objectID": "materials/02-prokaryotes/2.1-know_your_bug.html#exercises",
    "href": "materials/02-prokaryotes/2.1-know_your_bug.html#exercises",
    "title": "Know Your Bug",
    "section": "Exercises",
    "text": "Exercises\n\nTB practical\n\n\nPneumococcus practical"
  },
  {
    "objectID": "materials/02-prokaryotes/2.4-TB_practical.html",
    "href": "materials/02-prokaryotes/2.4-TB_practical.html",
    "title": "TB Phylogenetics",
    "section": "",
    "text": "Questions\n\n\n\n\nHow can I produce a multiple sequence alignment of TB sequences?\nHow can I build a phylogenetic tree from my alignment?\nHow can I visualize and annotate my tree with metadata?\nHow can I scale my tree based on sampling dates?\n\n\n\n\nUse nf-core/bactmap to produce a multiple sequence alignment.\nUse IQ-tree for phylogenetic tree inference.\nVisualize and annotate tree in R with ggtree library.\nUse BEAST2 to obtain a time-scaled phylogenetic tree using sample collection dates.\n\n\n\n\n\n\n\n\n\n\n\n\nFor this practical, we’re going to build a phylogenetic tree using a multiple sequence alignment we generate with nf-core/bactmap.\n\n\n\nsnp-sites \\\n    GPSC33.masked.aln \\\n    -o GPSC33.masked_snps.aln\n\nsnp-sites \\\n    -C GPSC33.masked.aln \\\n    >  GPSC33.constant_sites.txt\niqtree \\\n    -fconst GPSC33.constant_sites.txt \\\n    -s GPSC33.masked_snps.aln \\\n    -nt auto \\\n    -ntmax 8 \\\n    -mem 8G \\\n    -m GTR \\\n    -bb 1000\n\n\n\n\n\n\nThe trees that we build from sequence data are scaled using the mutation rate estimated from the sequence alignments. This is useful if we want to know, for example, on average how many mutations separate different branches of the tree.\nAnother way to scale trees is to use time. For most genome sequences, we usually have information about their date of collection, and this can be used to scale the phylogeny using the date information. The idea is to rescale the trees such that the x-axis of the tree represents a date rather than number of mutations.\nThere are a number of tools available for generating time-scaled trees which vary in complexity and the resources, including time, they require. For this practical we’re going to use BEAST2.\n\n\n\n\nKey Points - We can time-scale trees using sample collection date information. The program BEAST2 can be used to achieve this."
  },
  {
    "objectID": "materials/02-prokaryotes/2.3-reference_picking.html",
    "href": "materials/02-prokaryotes/2.3-reference_picking.html",
    "title": "Picking a reference",
    "section": "",
    "text": "Learning Objectives\n\n\n\n\nList skills and concepts that learners should grasp after this lesson."
  },
  {
    "objectID": "materials/02-prokaryotes/2.2-alignments.html",
    "href": "materials/02-prokaryotes/2.2-alignments.html",
    "title": "Generating alignments",
    "section": "",
    "text": "Learning Objectives\n\n\n\n\nList skills and concepts that learners should grasp after this lesson."
  },
  {
    "objectID": "materials/02-prokaryotes/2.5-pneumo_practical.html",
    "href": "materials/02-prokaryotes/2.5-pneumo_practical.html",
    "title": "Pneumococcus practical",
    "section": "",
    "text": "Questions\n\n\n\n\nHow can I produce a multiple sequence alignment of pneumococcal sequences?\nHow can I build a phylogenetic tree from my alignment?\nHow can I visualize and annotate my tree with metadata?\nHow can I scale my tree based on sampling dates?\n\n\n\n\nUse nf-core/bactmap to produce a multiple sequence alignment.\nUse Gubbins to identify recombinant regions\nMask recombinant regions in multiple sequence alignment\nUse IQ-tree for phylogenetic tree inference.\nVisualize and annotate tree in Microreact.\n\n\n\n\n\n\nStreptococcus pneumoniae (the pneumococcus)is a gram-positive human commensal that also causes a significant disease burden with pneumococcal-related diseases such as pneumonia and meningitis responsible for up 500,000 deaths in children <5 years old each year. The primary pneumococcal virulence factor is the polysaccharide capsule that surrounds the cell. One hundred different polysaccharide capsules (serotypes) have been identified to date and the conjugate vaccines that are routinely administered in vaccination programmes around the world typically target the 10-13 serotypes most prevalent in invasive pneumococcal disease (IPD).\nThe Global Pneumococcal Sequencing (GPS) project was set up to help understand the global picture of pneumococcal evolution during vaccine introductions using whole-genome sequencing. By the end of 2019, the GPS project had sequenced more than 26,000 pneumococcal genomes from more than 50 countries. As well as investigating the pre- and post-vaccine pneumococcal population structure, 13,454 GPS genomes were combined with an additional 7,000 published pneumococcal genomes to identify clusters of sequences defined as Global Pneumococcal Sequence Clusters (GPSCs). The study identified 621 GPSCs and 35 GPSCs contained more than 100 isolates, accounting for the majority of genomes included in the dataset. These clusters are increasingly being used as the standard method of lineage assignment in pneumococcus as tools now exist to allow new genomes to be assigned to existing clusters or else form the basis of novel clusters.\nUptake and incorporation of DNA from the environment into the pneumococcal chromosome via transformation and homologous recombination has been shown to contribute more to nucleotide variation than mutation in the pneumococcus. As well as being biologically important, recombination obscures the true phylogenetic signal of vertical descent and needs to be accounted for when inferring pneumococcal phylogenies.\n\n\n\nThe dataset chosen for this practical consists of 170 isolates from the GPSC33 lineage. Isolates were collected in South Africa and Malawi as part of the GPS project between 2009 and 2014.\n\n\n\n\n\n\nData for this section\n\n\n\nWe will work from the course materials folder called 02-prokaryotes, which contains the following files:\n\nreference/GCA_901213345.1_12837_1_32_genomic.fna is the reference genome\ndata is the directory containing the fastq files we’re going to map to the reference genome\nsample_annotation.csv is a comma-separated values (CSV) file with information about each sample such as the date of collection and country they were collected in. We will use this table to annotate our phylogenetic trees. This table can also be opened in a spreadsheet program such as Excel.\n\n\n\n\n\n\nThe first step in building a phylogenetic tree is to generate a multiple sequence alignment. To do this, we’re going to map the sequence data for our 170 pneumococcal genomes to a reference, in this case one of the GPS genomes, using the nf-core/bactmap pipeline.\nFirst create a directory a directory for the output:\nmkdir -p results/bactmap\nNow create a samplesheet.csv file containing the sample IDs and the location of the files to be mapped:\npython fastq_dir_to_samplesheet.py \\\n    data \\\n    samplesheet.csv \\\n    -r1 _1.fastq.gz \\\n    -r2 _2.fastq.gz\nThe meaning of the options used is:\n\ndata is the directory containing the fastq files\nsamplesheet.csv the name of the input file for nf-core/bactmap\n-r1 and -r2 the suffixes of the forward and reverse sequence files. By default the fastq_dir_to_samplesheet.py script will use everything before this to create the sample IDs\n\n\n\n\n\n\n\nNextflow and nf-core\n\n\n\nWhat is nextflow and nf-core\n\n\nThen run the command to generate a reference based alignment:\nnextflow run nf-core/bactmap \\\n    -profile singularity \\\n    --input samplesheet.csv \\\n    --reference reference/GCA_901213345.1_12837_1_32_genomic.fna \\\n    --genome_size 2.0mb \\\n    --outdir results/bactmap\nnf-core/bactmap has a number of optional arguments but for now these are the ones we’re going to use:\n\nnextflow run is the software and option we’re going to use to run the nf-core/bactmap pipeline\n-profile singularity tells nextflow to pull singularity containers for each tool in the pipeline. We could also use docker or conda\n--input samplesheet.csv tells nextflow which samples to analyse and where they’re located\n--reference reference/GCA_901213345.1_12837_1_32_genomic.fna is the reference sequence we’re going to map our samples to\n--genome_size 2.0mb is used by the pipeline to calculate the approximate genome coverage in the fastq files. By default the pipeline uses a tool called rasusa to subsample the fastq files so the genome coverage is <= 100X\n--outdir results/bactmap is the directory we’re going to save the outputs from nf-core/bactmap to\n\nVisit the nf-core/bactmap page for further information on running the pipeline with different options.\nWe can look at the output directory (results/bactmap) to see the various directories containing output files created by nf-core/bactmap:\n\nbwa/index contains the index of the reference sequence\nfastp contains the results of the trimming and adapter removal performed by fastp\nfastqc contains QC metrics for the fastq files generated with fastQC\nmultiqc contains a html file containing summaries of the various outputs\npipeline_info contains information about the pipeline run\npseudogenomes contains consensus fasta files for each sample which have the sample variants compared to the reference included. The alignment we’ll use for the next step can also be found in this directory (aligned_pseudogenomes.fas)\nrasusa contains the subsampled post-trimmed fastq files\nsamtools contains the sorted bam files and indices created by bwa and samtools as part of the mapping process\nsnpsites contains a variant alignment file created from aligned_pseudogenomes.fas that can be used as input for tree inference tools\nvariants contains filtered vcf files which contain the variants for each sample\n\n\n\n\n\n\n\nFile formats used in the nf-core/bactmap pipeline\n\n\n\n\nfastq\nfasta\nbam\nvcf\n\n\n\n\n\n\nGubbins (Genealogies Unbiased By recomBinations In Nucleotide Sequences) is an algorithm that iteratively identifies loci containing elevated densities of base substitutions while concurrently constructing a phylogeny based on the putative point mutations outside of these regions. We’re going to use Gubbins to identify the recombinant regions in the alignment we generated using nf-core/bactmap.\nFirst create a directory a directory for the output:\nmkdir -p results/gubbins\nNow move the aligned_pseudogenomes.fas created by nf-core/bactmap to results/gubbins:\nmv results/bactmap/pseudogenomes/aligned_pseudogenomes.fas results/gubbins\nBefore we run Gubbins, we need to remove the reference sequence from the alignment. Change directory to results/gubbins and run the following command:\ncd results/gubbins\n\nseqkit grep -v \\\n    -p 'CAAKRB010000001.1|CAAKRB010000002.1|CAAKRB010000003.1|CAAKRB010000004.1|CAAKRB010000005.1|CAAKRB0...' \\\n    aligned_pseudogenomes.fas > aligned_pseudogenomes_noref.fas\nNow we can run Gubbins:\nrun_gubbins.py \\\n    --prefix GPSC33 \\\n    --first-tree-builder rapidnj \\\n    --first-model JC \\\n    --tree-builder raxmlng \\\n    --model GTR \\\n    --threads 8 \\\n    aligned_pseudogenomes_noref.fas\nThe meaning of the options used is:\n\n--prefix GPSC33 is the prefix of the Gubbins output files\n--first-tree-builder rapidnj is the name of the phylogenetic inference tool we’ll use to build the starting tree for Gubbins. rapid-nj is a quick way to generate a starting tree for Gubbins\n--first-model JC is the nucleotide substitution model used to calculate the starting tree, in this instance Jukes-Cantor\n--tree-builder raxmlng is the name of the phylogenetic inference software Gubbins will use to build the rest of the trees. raxml-NG is a commonly used tool designed to work with large genome datasets\n--model GTR is the model to that raxml-NG will use, in this case General time reversible\n--threads 8 is the number of threads that Gubbins will use for parallelisation\naligned_pseudogenomes.fas is the alignment file created by nf-core/bactmap\n\n\n\n\n\n\n\nNucleotide substitution models\n\n\n\n\nJukes-Cantor (JC)\nGeneral time reversible (GTR)\nHasegawa, Kishino and Yano (HKY)\n\n\n\nWe can look at the output directory (results/gubbins) to see the various output files created by gubbins:\n\nGPSC33.recombination_predictions.embl contains the recombination predictions in EMBL file format\nGPSC33.recombination_predictions.gff contains the recombination predictions in GFF format\nGPSC33.branch_base_reconstruction.embl contains the base substitution reconstruction in EMBL format\nGPSC33.summary_of_snp_distribution.vcf contains the VCF file summarising the distribution of point mutations\nGPSC33.per_branch_statistics.csv contains the per branch reporting of the base substitutions inside and outside recombination events\nGPSC33.filtered_polymorphic_sites.fasta is a FASTA format alignment of filtered polymorphic sites used to generate the phylogeny in the final iteration\nGPSC33.filtered_polymorphic_sites.phylip is a Phylip format alignment of filtered polymorphic sites used to generate the phylogeny in the final iteration\nGPSC33.final_tree.tre contains the final phylogeny in Newick format; branch lengths are in point mutations\nGPSC33.node_labelled.final_tree.tre is the final phylogenetic tree in Newick format but with internal node labels; branch lengths are in point mutations\nGPSC33.log is a log file specifying the software used at each step of the analysis, with accompanying citations\n\n\n\n\nThe outputs from Gubbins can be visualised using Phandango. Click on the link then drag the following files onto the Gubbins page:\n\nGPSC33.final_tree.tre\nGPSC33.recombination_predictions.gff\n\nYou should see something like this:\n\n\n\nThe red bars are recently recombined regions whilst the blue bars are regions that recombined more distantly in the evolutionary history of this lineage. The graph along the bottom shows the frequency of recombinant regions across the genome\n\n\n\n\n\nRather than using the tree produced by Gubbins, we’re going to infer our own phylogenetic tree. Before we do this, we have to mask the regions of recombination identified by Gubbins in our alignment using a script included as part of the Gubbins package:\nmask_gubbins_aln.py \\\n    --aln aligned_pseudogenomes_noref.fas \\\n    --gff GPSC33.recombination_predictions.gff \\\n    --out GPSC33.masked.aln\n\n\n\nThere are a number of different tools for phylogenetic inference via maximum-likelihood and some of the most popular tools used for phylogenetic inference are FastTree, IQ-Tree and RAxML-NG. For this practical, we’re going to use IQ-Tree.\nFirst, create a directory for the IQ-tree analysis and copy the masked alignment into the new directory:\nmkdir -p results/iqtree\n\ncp results/gubbins/GPSC33.masked.aln results/iqtree\nPhylogenetic inference software such as IQ-tree typically takes as input an alignment of just the variant sites in a multiple sequence alignment. So, before running IQ-tree, we need to extract the variant sites from the masked alignment. To ensure that the branch lengths are correctly scaled, we also need to tell IQ-tree how many invariant or constant sites there are in our multiple sequence alignment. To do both those things, we can use a tool called snp-sites. Run the following commands in the results/iqtreedirectory:\nsnp-sites \\\n    GPSC33.masked.aln \\\n    -o GPSC33.masked_snps.aln\n\nsnp-sites \\\n    -C GPSC33.masked.aln \\\n    > GPSC33.constant_sites.txt\nNow we can run IQ-tree using the two files we just created with snp-sites as input:\niqtree \\\n    -fconst $(cat GPSC33.constant_sites.txt) \\\n    -s GPSC33.masked_snps.aln \\\n    -nt auto \\\n    -ntmax 8 \\\n    -mem 8G \\\n    -m GTR \\\n    -bb 1000\nThe meaning of the options used is:\n\n--fconst $(cat GPSC33.constant_sites.txt) tells IQ-tree to extract the number of invariant sites from the file we created using SNP-sites\n-s GPSC33.masked_snps.aln is the the variant site alignment\n-nt auto autodetects the number of available cores\n-ntmax 8 is the maximal number of cores to use\n-mem 8G is the maximal RAM usage in GB\n-m GTR tells IQ-tree to use the General time reversible model of nucleotide substitution\n-bb 1000 is the number of ultrafast bootstraps to run\n\nWe can look at the output directory (results/iqtree) to see the various output files created by IQ-tree:\n\nGPSC33.masked_snps.aln.iqtree is a text file containing a report of the IQ-Tree run, including a representation of the tree in text format.\nGPSC33.masked_snps.aln.treefile is the estimated tree in NEWICK format. We can use this file with other programs, such as FigTree, to visualise our tree.\nGPSC33.masked_snps.aln.log is the log file containing the messages that were also printed on the screen.\nGPSC33.masked_snps.aln.bionj is the initial tree estimated by neighbour joining (NEWICK format).\nGPSC33.masked_snps.aln.mldist is the maximum likelihood distances between every pair of sequences.\nGPSC33.masked_snps.aln.ckp.gz is this is a “checkpoint” file, which IQ-Tree uses to resume a run in case it was interrupted (e.g. if you are estimating very large trees and your job fails half-way through).\n\n\n\n\nThere are many programs that can be used to visualise phylogenetic trees. To visualise our phylogenetic tree, along with the associated metadata, we’re going to use an online tool called Microreact. Microreact allows for quick, attractive visualisations of phylogenetic trees and metadata. Before we upload our data we need to change file suffix on our phylogenetic tree so it’s recognised by Microreact:\nmv GPSC33.masked_snps.aln.treefile GPSC33.masked_snps.aln.nwk\nNow, click on the Microreact link. This will take you to the Microreact homepage. To upload our tree (GPSC33.masked_snps.aln.nwk) and metadata (sample_annotation.csv), click UPLOAD then drag and drop the two files together (you may need to copy one of the files to the location of the other). You should see the following:\n\n\n\nUpload prompt for Microreact\n\n\nClick CONTINUE and then click CONTINUE on the two subsequent prompts. You should know see a page divided into three sections: a map showing where the samples were collected, the phylogenetic tree with the serotype of the samples annotated on the tree and a timeline of when the samples were collected.\n\n\n\nGPSC33 phylogenetic tree and metadata\n\n\nNow let’s change what metadata we annotate on the phylogenetic tree. Click the “Eye” on the top left of the screen and change In_Silico_Serotype to Country. Now the tree looks a bit more interesting as we can see that the two clades within the tree correspond to where the samples were collected (red for Malawi and mauve for South Africa).\n\n\n\nGPSC33 phylogenetic tree coloured by country\n\n\n\nKey Points\n\nTo build a phylogenetic tree we need a multiple sequence alignment of the sequences we want to infer a tree from.\nAlignments are usually done against a reference genome.\nWe can use the pipeline nf-core/bactmap to produce a multiple sequence alignment.\nWe can identify and remove regions of recombination from our multiple sequence alignment usinf Gubbins\n\nThe software IQ-tree can be used for inferring trees from an alignment using maximum likelihood. Although we used the GTR model, this software supports a wide range of substitution models.\nWe can use Microreact to quickly create attractive visualisations of our trees and associated metadata."
  },
  {
    "objectID": "materials/02-prokaryotes/00-template.html",
    "href": "materials/02-prokaryotes/00-template.html",
    "title": "Lesson Title Here",
    "section": "",
    "text": "Learning Objectives\n\n\n\n\nList skills and concepts that learners should grasp after this lesson."
  },
  {
    "objectID": "materials/03-eukaryotes/00-template.html",
    "href": "materials/03-eukaryotes/00-template.html",
    "title": "Lesson Title Here",
    "section": "",
    "text": "Learning Objectives\n\n\n\n\nList skills and concepts that learners should grasp after this lesson."
  }
]